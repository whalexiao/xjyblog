---
title: 20190904CCF-推荐系统
date: 2020-02-09 10:32:51
tags: [CCF,Algorithm]
categories: "CCF-CSP"
mathjax: true
---
## 题目信息
编号： 201909-4
试题名称： 推荐系统
时间限制： 5.0s
内存限制： 512.0MB
<!-- more -->
## 题目描述
某电商有编号为0到m-1的m类商品，包括家电、汽车、电动车、面包、化妆品等。对于每个app新用户，每类商品初始有编号不同的n个商品，包括各个商家、品牌、供应商等。在任何时刻，同类的任意两个商品的编号各不相同，不同类的任意两个商品的编号可能相同。app会给每个商品打分。初始时，各类商品的编号和得分都相同。在用户使用app时，会产生有效信息，包括喜欢、不喜欢等。app会根据这些信息，在某类商品增加或删除商品。app每次会推荐一部分商品给用户看。一个简单的想法是，选出各类所有商品中得分最大的若干商品。
该方法虽然简单，但是如果某类商品可能得分特别高，这种简单想法就无法保证推荐商品的多样性。因此，app查询得分最大的若干商品，同时限制各类商品个数不能超过一个阅值。将上述过程抽象成3中操作：操作1、2、3，分别对应增加、删除、查询操作：
1 type commodity score表示在type类商品中增加编号为commodity的商品，该商品分数为score
2 type commodity表示在type类商品中删除编号为commodity的商品。
3 k k_0 k_1 k_{m-1}表示在各类所有商品中选出不超过K个（不一定要达到K个）得分最大的商品，同时第i（0<=i<m）类商品的个数不超过k_i。在查询时，如果第a（0<=a<m）类商品中编号为b的商品和第A（0<=A<m）类商品中编号为B的商品得分相同：
1，当a=A时，选取编号为min（b，B）的商品；
2，当a≠A时，选取第min（a，A）类商品。
## 输入格式
从标准输入读入数据。
输入的第一行包含两个正整数m和n，保证n<=3x10^4和m<=50.
接下来n行，每行两个正整数id和score。第1+j（1<=j<=n）行表示所有m类商品的第j个商品的编号和得分。
接下来一行包含一个正整数opnum，表示操作总数，保证n<=10^5。其中，查询操作一共有opask个，保证opask <= 10^2.
接下来opnum行，每行若干个正整数，格式对应1 type commodity score、2
type commodity、3 K k_0 k_1 … k_{m-1}，其中，K<=10^2，k_0 k_1 … k_{m-1}<=10^5.
## 输出格式
输出到标准输出。
输出共opask×m，对应opask个查询操作。第r×m+c，0<=r<opask，1<=c<=m行表示，在第r个查询操作中，第c类商品选出的商品编号，同类商品的编号从小到大输出。如果r个查询操作中，第c类商品没有选出任何商品，则该行输出-1
## 输入样例
2 3
1 3
2 2
3 1
8
3 100 1 1
1 0 4 3
1 0 5 1
3 10 2 2
3 10 1 1
2 0 1
3 2 1 1
3 1 1 1
## 输出样例
1
1
1 4
1 2
1
1
4
1
4
-1
## 子任务

![子任务](子任务.png)

## C++代码
```c++ 
#include<iostream>
#include<string>
#include<vector>
#include<set>
#include<cstdlib>
#include<map>
#include<algorithm>
using namespace std;

struct Commodity{
	int type;
	int id;
	int score;
	friend bool operator < (struct Commodity const &c1,struct Commodity const &c2){
		if (c1.score>c2.score){
			return true;
		}else if(c1.score==c2.score){
			if(c1.type==c2.type){
				return c1.id<c2.id;
			}else{
				return c1.type<c2.type;
			}
		}else{
			return false;
		}
	}
};
set<Commodity> commodities;
map<int,map<int,int> > type2score;
 
void insert(int type, int id, int score){
	Commodity c = {type,id,score};
	commodities.insert(c);
	type2score[type][id]=score;
}


void del(int type, int id){
	type2score[type][id]=-1;
}

void search(int k[], int K, int m){
	int num[m]={0};
	vector<vector<int> >ids(m);//存商品id 
	int i=0;
	for(set<Commodity>::iterator iter=commodities.begin();iter!=commodities.end()&&i<K;iter++){
		if(type2score[iter->type][iter->id]!=iter->score)
			continue;
		num[iter->type]++;
		if(num[iter->type]>k[iter->type]){
			i++;	
			continue;	
		}
		ids[iter->type].push_back(iter->id);
		i++;
	}

	for(int i=0;i<ids.size();i++){
		if(ids[i].size()==0){
			cout<<"-1"<<'\n';
			continue;
		}
		for(int j=0;j<ids[i].size();j++){
			cout<<ids[i][j];
			if(j==ids[i].size()-1) cout<<'\n';
			else cout<<" ";
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int m,n,op;//m类商品,n行初始化,op个操作 
	cin>>m>>n;
	//n行 id score 
	for(int i=0;i<n;i++){
		int id,score;
		cin>>id>>score;
		Commodity commodity={0, id,score};
		for(int j=0;j<m;j++){
			commodity.type = j;
			commodities.insert(commodity);
			type2score[j][id] = score;
		}
	}
	cin>>op;
	for(int i=0;i<op;i++){
		int opcode;
		int type,id,score,K;
		int k[m];
		cin>>opcode;
		if(opcode==1){
			cin>>type>>id>>score;
			insert(type, id, score);
		}else if(opcode==2){
			cin>>type>>id;
			del(type,id); 
		}else if(opcode==3){
			cin>>K; 
			for(int j=0;j<m;j++){
				cin>>k[j];
			}
			search(k,K,m);
		}
	}	 
	return 0;
}
``` 